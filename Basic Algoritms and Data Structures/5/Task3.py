import timeit

TEXT_1 = """ ВИКОРИСТАННЯ АЛГОРИТМІВ У БІБЛІОТЕКАХ МОВ ПРОГРАМУВАННЯ
Автори публiкації: Коваленко О.О., Корягіна Д.О. Вінницький національний технічний університет
Анотація: У данній статті було розглянуто використання алгоритмів у бібліотеках мов програмування. Ключові слова: алгоритми, сортування, лінійний пошук, двійковий пошук, пошук стрибками, інтерполяційний пошук, експоненціальний пошук, жадібний алгоритм.
Стаття
За всю історію комп'ютерних наук склалося розуміння, які алгоритми та структури даних (способи їх зберігання) потрібні для вирішення практичних завдань, певний набір, який повинен знати кожен розробник. Наприклад, сортування: товари в магазині сортують за вартістю або терміну придатності, а ресторани – за віддаленістю або рейтингу. Хеш-таблиці допомагають перевірити коректність пароля та не зберігати його на сайті у відкритому вигляді, графи – знаходити найкоротший шлях і зберігати зв'язки між користувачами в соцмережах.
Алгоритми – це послідовність точно визначених дій, які призводять до вирішення поставленої задачі чи певного завдання і на сьогодні уже створено величезну кількість алгоритмів для вирішення важких задач, що полегшують написання коду будь-якому програмісту, особливо початківцям [1].
Метою роботи є виявлення найбільш популярних алгоритмів у бібліотеках мов програмування.
Усі алгоритми та структури даних вже давно реалізовані в бібліотеках популярних мов програмування. Більше ніхто не пише вручну алгоритм сортування чисел, а щоб користуватися хеш-таблицями, навіть не потрібно знати, як вони влаштовані.
Але наявність безлічі готових бібліотек не означає, що не потрібно розуміти, як влаштовані алгоритми. Фундаментальні знання допомагають дізнатися, що всередині, як воно працює і чому одне рішення краще, аніж інше у конкретній ситуації. Якщо зрозуміти, як влаштовані класичні алгоритми, то можна створювати власні рішення, комбінувати методи один з одним, щоб вирішувати більш складні завдання.
У програмуванні стандартна бібліотека — це бібліотека, що доступна в усіх реалізаціях даної мови програмування. Зміст такої бібліотеки зазвичай описано у специфікації мови, однак також він може частково або повністю визначатися більш неформальними практиками програмістів, що користуються нею. Більшість стандартних бібліотек включають у себе визначення принаймні таких найчастіше використовуваних інструментів як:
Алгоритми (такі як алгоритми сортування); 
Структури даних (наприклад, списки, дерева, хеш-таблиці); 
Взаємодія з відповідною платформою (введення-виведення, системні виклики та ін.). 
Пошук – поширена дія, яка виконується в бізнес-додатках. Розглянемо деякі реалізації відомих алгоритмів пошуку [2] на Java.
Лінійний або послідовний пошук – найпростіший алгоритм пошуку. Він рідко використовується через свою неефективність. По суті, це метод повного перебору, і він поступається іншим алгоритмам [3]. У лінійного пошуку немає передумов до стану структури даних. Алгоритм шукає елемент у заданій структурі даних, поки не досягне кінця структури. При знаходженні елемента повертається його позиція у структурі даних. Якщо елемент не знайдений, повертаємо -1. Лінійний пошук можна використовувати для малого, несортоване набору даних, який не збільшується в розмірах.
Реалізація:
public static int linearSearch(int arr[], int elementToSearch) {
for (int index = 0; index < arr.length; index++) {
if (arr[index] == elementToSearch)
return index;
}
return -1;
}
Двійковий або логарифмічний пошук часто використовується через швидкий час пошуку. Цей вид пошуку вимагає попереднього сортування набору даних. Алгоритм ділить вхідну колекцію на рівні половини, і з кожною ітерацією порівнює цільовий елемент з елементом у середині. Пошук закінчується при знаходженні елемента. Інакше продовжуємо шукати елемент, розділяючи і вибираючи відповідний розділ масиву. Цільовий елемент порівнюється із середнім. Ось чому важливо мати відсортовану колекцію при використанні двійкового пошуку [4]. Пошук закінчується, коли firstIndex(вказівник) досягає lastIndex(останнього елемента). Отже перевіривши весь масив Java не було знайдено елемента.
Реалізація:
public static int binarySearch(int arr[], int elementToSearch) {
int firstIndex = 0;
int lastIndex = arr.length - 1;
// умова припинення(елемент не представлено)
while(firstIndex <= lastIndex) {
int middleIndex = (firstIndex + lastIndex) / 2;
// якщо середній елемент – цільовий елемент, повернути його індекс
if (arr[middleIndex] == elementToSearch) {
return middleIndex;
}
// якщо середній елемент менше
// направляємо індекс у middle+1, забираючи першу частину з
переглянутого
else if (arr[middleIndex] < elementToSearch)
firstIndex = middleIndex + 1;
// якщо середній елемент більше
// направляємо індекс у middle-1, забираючи другу частину з
переглянутого
else if (arr[middleIndex] > elementToSearch)
lastIndex = middleIndex - 1;
}
return -1;
}
Пошук стрибками, цей алгоритм від двійкового пошуку відрізняється рухом виключно вперед. Такий пошук вимагає відсортованої колекції. Стрибаючи вперед на інтервал sqrt (arraylength), досягаючи елемента більшого, ніж поточний елемент або кінця масиву. При кожному стрибку записується попередній крок. Стрибки припиняються, коли знайдений елемент більше шуканого. Потім запускаємо лінійний пошук між попереднім і поточним кроками. Це зменшує поле пошуку та робить лінійний пошук життєздатним варіантом [5].
Реалізація:
public static int jumpSearch(int[] integers, int elementToSearch) {
int arrayLength = integers.length;
int jumpStep = (int) Math.sqrt(integers.length);
int previousStep = 0;
while (integers[Math.min(jumpStep, arrayLength) - 1] < elementToSearch) {
previousStep = jumpStep;
jumpStep += (int)(Math.sqrt(arrayLength));
if (previousStep >= arrayLength;
return -1;
}
while (integers[previousStep] < elementToSearch) {
previousStep++;
if (previousStep == Math.min(jumpStep, arrayLength));
return -1;
}
if (integers[previousStep] == elementToSearch)
return previousStep;
return -1;
}
Інтерполяційний пошук використовується для пошуку елементів у відсортованому масиві. Він корисний для рівномірно розподілених у структурі даних. При рівномірно розподілених даних місцезнаходження елемента визначається точніше. Тут і розкривається відміна алгоритму від бінарного пошуку, де потрібно знайти елемент у середині масиву. Для пошуку елементів у масиві алгоритм використовує формули інтерполяції. Найефективніше застосовувати ці формула для великих масивів. В іншому випадку алгоритм працює як лінійний пошук.
Реалізація:
public static int interpolationSearch(int[] integers, int elementToSearch) {
int startIndex = 0;
int lastIndex = (integers.length - 1);
while ((startIndex <= lastIndex) && (elementToSearch >=
integers[startIndex]) &&
(elementToSearch <= integers[lastIndex])) {
122                                                                                                                                                        // використовуємо формулу інтерполяції для пошуку можливої кращої
позиції для відомого елемента
int pos = startIndex + (((lastIndex-startIndex) /
(integers[lastIndex]-integers[startIndex]))*
(elementToSearch - integers[startIndex]));
if (integers[pos] == elementToSearch)
return pos;
if (integers[pos] < elementToSearch)
startIndex = pos + 1;
else
lastIndex = pos - 1;
}
return -1;
}
Експоненціальний пошук використовується для пошуку елементів шляхом переходу в експоненціальні позиції, тобто у другу ступінь. У цьому пошуку потрібно знайти порівняно менший діапазон і застосовувати на ньому двійковий алгоритм для пошуку елемента. Для роботи алгоритму колекція повинна бути відсортована. Експоненціальний пошук використовується з великими масивами, коли бінарний пошук витратний. Такий пошук розділяє дані на більш доступні для пошуку розділи.
Реалізація:
public static int exponentialSearch(int[] integers, int elementToSearch) {
if (integers[0] == elementToSearch)
return 0;
if (integers[integers.length - 1] == elementToSearch)
return integers.length;
int range = 1;
while (range < integers.length && integers[range] <= elementToSearch) {
range = range * 2;
}
return Arrays.binarySearch(integers, range / 2, Math.min(range, integers.length),
elementToSearch);
}
Також, у теорії алгоритмів жадібні алгоритми відіграють важливу роль. Вони прості для розуміння та реалізації, працюють порівняно швидко, відомо багато різноманітних задач, які можна вирішити за допомогою таких алгоритмів [6]. Однак не завжди можна довести можливість застосовності жадібного алгоритму для знаходження точного вирішення багатьох завдань.
Жадібний алгоритм – метод розв'язання оптимізаційних задач, заснований на тому, що процес прийняття рішення можна розбити на елементарні кроки, на кожному з яких приймається окреме рішення. Рішення, прийняте на кожному кроці, має бути оптимальним тільки на поточному кроці та повинне прийматися без врахування попередніх або наступних рішень.
У жадібному алгоритмі завжди робиться вибір, який здається найкращим у даний момент - тобто виробляється локально оптимальний вибір у надії, що він приведе до оптимального рішення глобальної задачі. Жадібні алгоритми не завжди приводять до оптимального рішення, але в багатьох завданнях вони дають потрібний результат. Цей алгоритм володіє достатньою потужністю та добре підходить для широкого класу задач. Алгоритми пошуку мінімальних остових дерев є класичним прикладом застосування жадібної стратегії [7].
Ознаки того, що задачу можливо вирішити за допомогою жадібного алгоритму:
задачу можна розбити на підзадачі; 
величини, що розглядаються в задачі, можна дробити так само на підзадачі; 
сума оптимальних рішень для двох підзадач надає оптимальне рішення для всієї задачі. 
Розглянемо простий приклад завдання, що розв’язується жадібним алгоритмом:
Наприклад, розглянемо проблему виплати 98 копійок монетами номіналом 1, 2, 5, 10 і 25 копійок так, щоб загальна кількість монет було мінімально.
Рішення: Жадібний алгоритм у цьому випадку полягає в тому, щоб на кожному кроці побудови рішення використовувати монети максимального номіналу, і тим, щоб їх було якомога менше (досягнення локального мінімуму). Для початку необхідно три монети по 25 копійок (4 монети дають більшу суму, ніж потрібно). Залишається виплатити 98 – 25*3 = 23 копійки.
На наступному кроці потрібно обрати чергові найбільші за номіналом монети, якими можна видати решту суми, — дві монети по 10 копійок. Два наступні кроки – це по одній монеті номіналом 1 і 2 копійки, тим самим дозволяючи виплатити всю суму 7 монетами.
Висновки. Кожна система містить набір обмежень і вимог. Правильно підібраний алгоритм пошуку, що враховує ці обмеження відіграє визначальну роль у продуктивності системи. Алгоритми, призначені для вирішення завдань оптимізації, звичайно являють собою послідовність кроків, на кожному з яких надається деяка множина виборів. Визначення найкращого вибору, керуючись принципами динамічного програмування, у багатьох задачах оптимізації нагадує стрілянину з гармати по горобцях; іншими словами, для цих завдань краще підходять більш прості й ефективні алгоритми.
Тому основне завдання програміста - аналізувати і вирішувати проблеми, де код - це всього лише інструмент досягнення мети. Часто виникають проблеми, які важко вирішити, тоді програмісту слід розробити новий алгоритм або поміркувати, як використовувати існуючий. Адже якщо знати про принципи роботи алгоритмів, тоді існує більша ймовірність знайти краще рішення. Іноді навіть нову проблему можна звести до старої, але для цього потрібно володіти фундаментальними знаннями. """
#===================================================================================
TEXT_2 = """ Методи та структури даних для реалізації бази даних рекомендаційної системи соціальної мережі
Автори публiкації: Міхав В.В., Мелешко Є.В., Шимко С.В. Центральноукраїнський національний технічний університет,
Анотація
Метою даної роботи є дослідження та програмна реалізація методів і структур даних для побудови бази даних рекомендаційної системи, щоб порівняти ефективність їх використання за затратами часу та пам’яті. Наявність великої кількості різних методів реалізації баз даних викликає необхідність порівняльного аналізу та вибору оптимального методу і структури даних для зберігання інформації у рекомендаційних системах.
Було проведено дослідження різних структур даних, які можна використати для створення бази даних рекомендаційної системи, зокрема, досліджені зв’язний список, розгорнутий зв’язний список, хеш-таблиця, B-дерево, B+-дерево та бінарна діаграма рішень. Також було проведено серію експериментів на програмній імітаційній моделі рекомендаційної системи з різною кількістю агентів, предметів та сесій.
Відповідно до результатів проведених експериментів, розгорнутий список показав найкращі показники швидкодії та використання пам’яті. Структура B+-дерево показала результати, близькі до хеш-таблиці. Час доступу до окремого елементу в обох випадках сталий, але B+- дерево має певні переваги – елементи зберігаються відсортованими, а при зміні розміру немає необхідності розширювати область пам’яті. Найгірші результати показала структура даних бінарна діаграма рішень як за затратами часу, так і за затратами пам’яті. Профілювання показало, що 75% часу роботи тесту варіанту з розгорнутим списком зайняло генерування випадкових даних для програмного імітаційного моделювання агентів та предметів рекомендаційної системи, тож, саме сховище даних має високі показники ефективності.
Профілювання варіанту із інвертованим списком показало, що доступ до випадкових блоків займає більше часу через неможливість закешувати їх, тож, за умов реального навантаження час вставки нових даних буде більшим, а відносна ефективність застосування інвертованого списку зросте. Для найбільш ефективного використання пам’яті розмір блоку зв’язного списку має бути адаптований таким чином, щоб блоки були максимально заповнені. Блоки малого розміру зменшують втрати пам’яті, але збільшують час обходу всіх елементів списку та збільшують накладні витрати пам’яті.
Ключові слова: рекомендаційні системи, бази даних, структури даних, програмна імітаційна модель.
Стаття
Постановка проблеми. Рекомендаційні системи є важливою складовою соціальних мереж та значним чином впливають на те, яким користувачі сприймають інформаційний простір [1, 2]. Вибір методу представлення даних, якими оперує рекомендаційна система, має важливе значення, оскільки фективний спосіб побудови бази даних для роботи такої системи може зменшити кількість потрібних ресурсів та збільшити кількість доступних алгоритмів для формування списків рекомендацій. Отже, вибір методів реалізації СУБД для зберігання даних рекомендаційної системи є важливою науково-практичною задачею.
Аналіз останніх досліджень і публікацій. У наш час існує багато різних систем управління базами даних, крім реляційних баз даних широке застосування отримують бази даних типу NoSQL [3, 4]. СУБД типу NoSQL можуть бути реалізовані різними методами, зокрема, як Сховища типу «ключ-значення» (Key-value stores), Масштабовані розподілені сховища (Column Family (Bigtable) stores), графові СУБД (Graph Stores), документо-орієнтовані СУБД (Document Stores) тощо [3-5].
Спосіб зберігання даних рекомендаційної системи є важливим з точки зору якості її роботи, швидкості, можливостей масштабування, зручності виконання основних операцій з даними для формування рекомендацій.
Все частіше для зберігання даних рекомендаційних систем та інших додатків починають використовувати графові моделі [6-8], також графова форма представлення даних стає поширеною у програмному моделюванні складних систем та мереж [9-12], і це відбувається через ряд переваг графових моделей [8, 13]. Яскравим прикладом такого підходу являється побудова рекомендаційних систем з застосуванням графової СУБД Neo4j [14]. Графові моделі СУБД надають не лише зручний формат зберігання даних, а й зручний формат запитів. В документації до Neo4j є приклади реалізації алгоритмів формування рекомендацій запитами до цієї СУБД, що ілюструє її придатність для використання в рекомендаційних системах.
Наявність такої великої кількості різних методів реалізації баз даних та представлення інформації, що можна використати при побудові рекомендаційних систем, викликає необхідність порівняльного аналізу та вибору оптимального методу і структури даних для зберігання інформації рекомендаційних систем.
Постановка завдання. Метою даної роботи є дослідження та програмна реалізація методів і структур даних для реалізації бази даних рекомендаційної системи, щоб порівняти ефективність їх використання за затратами часу та пам’яті.
Для досягнення поставленої мети визначена програма дослідження, що складається з наступних завдань: – Дослідження існуючих структур даних для зберігання інформації та методів їх реалізації. – Програмна реалізація досліджених структур даних для створення бази даних рекомендаційної системи. – Проведення серії експериментів для порівняння ефективності використання розглянутих структур даних за затратами часу та пам’яті.
Об’єктом дослідження є процес зберігання даних рекомендаційної системи. Предметом дослідження є методи та структури даних для реалізації бази даних рекомендаційної системи. Методи дослідження базуються на методах розробки програмного забезпечення, теорії побудови баз даних, теорії алгоритмів та теорії статистичної обробки даних.
Виклад основного матеріалу. В статті проведено дослідження різних структур даних, які можна використати для створення бази даних рекомендаційної системи [15-17]. Наведемо класифікацію структур даних, що були обрані для дослідження та підходять для рішення поставленого завдання.
Зв’язний список (linked list) – це структура даних, у якій кожен елемент має вказівник на наступний елемент. Основна перевага цієї структури полягає у сталому часі додавання нового елементу. Проте для кожного елементу потрібно виділяти новий блок пам’яті, через що менеджер пам’яті спричиняє значні затримки та накладні витрати пам’яті.
Розгорнутий зв’язний список (unrolled list) – це зв’язний список, кожен елемент якого містить масив логічних елементів. Це дозволяє об’єднати переваги масивів та зв’язних списків у випадку додавання елементів у кінець списку. Об’єднання блоків логічних елементів у список дозволяє додавати нові елементи без зміни розміру блоку пам’яті, економити пам’ять на вказівниках та ефективніше використовувати кеш процесора завдяки послідовному розташуванню елементів. При послідовному заповненні гарантується, що незаповненим лишиться не більше одного блоку елементів.
Хеш-таблиця (hash map) – це структура даних, у якій пошук елементу здійснюється на основі його ключа. Хеш від ключа вказує, у якій комірці розташовується елемент. Якщо кілька елементів мають однаковий хеш, то виникає колізія. Існує два методи розв’язання колізій – закрита та відкрита адресації. При закритій адресації кожен елемент таблиці – це зв’язний список і усі елементи з однаковим хешем додаються до одного списку. Це найпростіший спосіб розв’язання колізій, але він використовує додаткову пам’ять для вказівників і не дозволяє використовувати переваги кешування при обході елементів хеш-таблиці. При відкритій адресації у випадку колізії обирається нова позиція елементу. Нова позиція може обиратися як за допомогою додаткової хеш-функції, так і шляхом зміщення позиції на декілька елементів. Пошук повторюється, доки не буде досягнуто порожнього елемента. Відкрита адресація використовує фіксований об’єм пам’яті і не потребує додаткових вказівників, але для ефективності операцій вставки і пошуку таблиця має бути заповнена не більш ніж на 50%, тож це спричиняє додаткові витрати пам’яті.
B-дерево (b-tree) – це структура даних представлена збалансованим, сильно розгалудженим деревом пошуку. Кожен вузол В-дерева, крім листків, є упорядкованим списком, у якому чергуються ключі і вказівники на потомків. Ключі вузла вказують інтервал, у якому знаходяться ключі потомку. В+-дерево (B+-tree) відрізняється тим, що воно зберігає усі значення у листкових вузлах, а листкові вузли мають посилання на сусіда, завдяки чому можна обійти усі значення без обходу всього дерева. Завдяки великій розгалуженості дерева підтримується мала висота дерева, що дозволяє переглядати невеликий об’єм даних за один прохід, а завдяки правилам побудови значення зберігаються у порядку зростання ключа.
Бінарні діаграми рішень (BDD) – це економна форма представлення булевих функцій у вигляді орієнтованого ациклічного графу. Вершини графу представляють аргументи функції, листки – її двійкові значення. Для додавання і вилучення ребер та зміни ваги ребер необхідно мати можливість редагувати дані графу. БДР дають можливість зберігати дані у стисненому вигляді та швидко отримувати значення функції за її параметрами, але редагування БДР вимагає складних обчислень. При представленні булевих функцій у формі БДР стало можливим розв’язувати багато проблем, які при традиційних представленнях структур нерозв’язні через значну розмірність таких представлень і складність операцій над ними. БДР можуть успішно застосовуватися фактично в кожній галузі, де потрібно обробляти дискретні структури даних.
Було проведено серію експериментів для порівняння ефективності використання розглянутих структур даних за затратами часу та пам’яті. Результати експериментів наведені у таблицях 1-2 та на рисунках 1-2.
Експерименти проводилися на комп’ютері з процесором AMD Ryzen 5 3600 та 32 Гб оперативної пам’яті. Для формування рекомендацій було використано колаборативну фільтрацію. З метою моделювання рекомендаційної системи розроблено програмну імітаційну модель, в якій було виділено три основні сутності – агент, сесія та предмет. На цій програмній моделі і проводилися експерименти.
Створена програмна імітаційна модель рекомендаційної системи для проведення експериментів працює за наступним принципом: Крок 1. Ініціалізація рекомендаційної системи: задається кількість агентів, предметів та сесій, а також розмір сесії та максимальна кількість вподобань.
Крок 2. Для кожного агента випадковим чином генерується від 1 до n вподобань.
Крок 3. Створюється m сесій. До кожної сесії закріплюється випадковим чином обраний агент. Потім серед вподобань цього агента випадковим чином обирається від 1 до k вподобань, які копіюються до сесії.
Крок 4. Випадковим чином обирається контрольна сесія, для якої буде сформовано рекомендацію.
Крок 5. Визначаються усі предмети, які належать до контрольної сесії.
Крок 6. Здійснюється пошук усіх сесій, вподобання яких мають перетин із вподобаннями контрольної сесії. На цьому етапі є можливість відфільтрувати сесії за розміром перетину.
Крок 7. Визначаються предмети, які буде рекомендовано. Здійснюється пошук усіх предметів, які належать хоча б одній з відібраних сесій, але не належать до контрольної сесії. На цьому етапі є можливість відфільтрувати предмети за кількістю закріплених сесій.
Було проведено 4 серії експериментів. Нижче наведено параметри кожної серії.
Параметри 1 серії експериментів: кількість агентів 65536, кількість предметів 131072, кількість сесій 262144, розмір сесії 192, максимальна кількість вподобань 1536.
Параметри 2 серії експериментів: кількість агентів 131072, кількість предметів 262144, кількість сесій 524288, розмір сесії 256, максимальна кількість вподобань 2048.
Параметри 3 серії експериментів: кількість агентів 262144, кількість предметів 524288, кількість сесій 1048576, розмір сесії 256, максимальна кількість вподобань 2048.
Параметри 4 серії експериментів: кількість агентів 524288, кількість предметів 1048576, кількість сесій 2097152, розмір сесії 256, максимальна кількість вподобань 2048.
У таблиці 1 наведено результати серії експериментів, проведених для порівняння часу формування рекомендацій системою при використанні різних структур даних для реалізації бази даних.
На основі одержаних результатів з таблиці 1 було побудовано графік, наведений на рисунку 1. Як видно з таблиці та рисунку найкращі результати по часу формування рекомендацій показали наступні структури даних – звичайний розгорнутий список та інвертований розгорнутий список. Також непогані результати показала структура даних B+-дерево.
У таблиці 2 наведено результати серії експериментів, проведених для порівняння кількості використаної пам’яті для формування рекомендацій системою при використанні різних структур даних для реалізації бази даних.
На основі одержаних результатів з таблиці 2 було побудовано графік, наведений на рисунку 2. Як видно з таблиці та рисунку найкращі результати за використаною пам’яттю для формування рекомендацій аналогічно, як і з результатами за затратами часу, показали наступні структури даних – звичайний розгорнутий список, інвертований розгорнутий список та B+-дерево.
Профілювання тестового коду показало, що значна відмінність у часі генерації сесій у варіантів з та без інвертованого списку спричинена затримкою доступу до елементів інвертованого списку, оскільки доступ постійно здійснюється до різних елементів. З реальними даними рішення з розгорнутим списком працюватиме дещо повільніше, оскільки кешування буде менш ефективним.
Структура розгорнутого списку дуже проста, тож в подальшому це дасть можливість використовувати багатопотокову роботу без блокувань.
Структура B+ tree показала результати, близькі до хеш-таблиці. Час доступу до окремого елементу в обох випадках сталий, але B+ tree має певні переваги: елементи зберігаються відсортованими, а при зміні розміру немає необхідності розширювати область пам’яті.
Розмір блоку розгорнутого списку впливає на швидкість роботи і на об’єм використаної пам’яті. Зменшення розміру блоку дозволяє зменшити втрати пам’яті, але збільшує час доступу до елементів.
Для прискорення пошуку окремих елементів у розгорнутому списку після заповнення блоку можна відсортувати його елементи. Це дасть можливість використовувати бінарний пошук замість лінійного та перевіряти лише ті блоки, де шуканий елемент належить до інтервалу, утвореного найменшим та найбільшим елементами блоку.
Перевага розгорнутого списку над іншими розглянутими структурами даних у використанні пам’яті значною мірою за рахунок того, що зберігається лише факт вподобання, без параметрів. При використанні 4 байт на елемент для зберігання параметру витрати пам’яті наближаються до максимальних витрат бінарних діаграм рішень.
Висновки. Відповідно до результатів проведених експериментів, розгорнутий список показав найкращі показники швидкодії та використання пам’яті. Профілювання показало, що 75% часу роботи тесту варіанту з розгорнутим списком зайняло генерування випадкових даних для програмного імітаційного моделювання агентів та предметів рекомендаційної системи, тож, саме сховище даних має високі показники ефективності. Профілювання варіанту із інвертованим списком показало, що доступ до випадкових блоків займає більше часу через неможливість закешувати їх, тож, за умов реального навантаження час вставки нових даних буде більшим, а відносна ефективність застосування інвертованого списку зросте. Для найбільш ефективного використання пам’яті розмір блоку зв’язного списку має бути адаптований таким чином, щоб блоки були максимально заповнені. Блоки малого розміру зменшують втрати пам’яті, але збільшують час обходу усіх елементів списку та збільшують накладні витрати пам’яті. """


#Рабін-Карп через хеш
def rabin_karp(text, pattern):
    h_pattern = hash(pattern)
    m = len(pattern)
    for i in range(len(text) - m + 1):
        if hash(text[i:i+m]) == h_pattern: #порівнюємо збіги
            if text[i:i+m] == pattern: return i
    return -1

#Боєр-Мур 
def boyer_moore(text, pattern):
    m = len(pattern)
    #таблиця переходу
    skip = {c: m - i - 1 for i, c in enumerate(pattern[:-1])}
    i = m - 1
    while i < len(text):
        if text[i] == pattern[-1]: #якщо остання збігається
            if text[i-m+1:i+1] == pattern: return i-m+1
        
        i += skip.get(text[i], m)
    return -1

#Кнут-Морріс-Пратт 
def kmp(text, pattern):
    #LPS
    lps = [0] * len(pattern)
    j = 0; i = 1
    while i < len(pattern):
        if pattern[i] == pattern[j]: j += 1; lps[i] = j; i += 1
        elif j > 0: j = lps[j-1]
        else: i += 1
    
    #пошук
    j = 0; i = 0
    while i < len(text):
        if pattern[j] == text[i]: i += 1; j += 1
        if j == len(pattern): return i - j
        elif i < len(text) and pattern[j] != text[i]:
            j = lps[j-1] if j > 0 else 0; 
            if j == 0: i += 1
    return -1

#визначення швидкості
def run_race(text_name, text, pattern):
    print(f"\n--- {text_name} (Шукаємо: '{pattern}') ---")
    
    t_bm = timeit.timeit(lambda: boyer_moore(text, pattern), number=1000)
    t_kmp = timeit.timeit(lambda: kmp(text, pattern), number=1000)
    t_rk = timeit.timeit(lambda: rabin_karp(text, pattern), number=1000)

    #результат
    results = [("Боєр-Мур", t_bm), ("КМП", t_kmp), ("Рабін-Карп", t_rk)]
    results.sort(key=lambda x: x[1]) #сортування

    for place, (name, time) in enumerate(results, 1):
        print(f"{place} місце: {name} ({time:.5f} сек)")

#вивід
run_race("Текст 1 (Алгоритми)", TEXT_1, "алгоритм")
run_race("Текст 2 (Бази Даних)", TEXT_2, "даних")
